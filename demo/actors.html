<section>
    <p>
        Actors, Baby!
    </p>
    <figure>
        <span class="score">0</span>
        <figcaption>Max Captured</figcaption>
    </figure>
</section>
<style>
 body {
     padding: 0;
     margin: 0;
     min-height: 100vh;
     display: flex;
     flex-direction: column;
 }
 svg {
     flex: 1;
     background-color: #AABBCC;
     border: 2px solid black;
     height: 100%;
     align-self: center;
     margin-bottom: 2em;
  }
 section {
     font-size: 1.3em;
     padding: 1em;
     display: flex;
 }
 p {
     flex: 1;
 }
 figure {
     display: flex;
     flex-direction: column;
 }
</style>
<svg viewBox="0 0 100 100" preserveAspectRatio="none">
</svg>

<script src="https://rawgit.com/Matt-Esch/virtual-dom/master/dist/virtual-dom.js"></script>
<script src="../dist/gimgen.js"></script>
<script>
const { gimgen, runGimgen, timeoutSignal, domEventToSignal, anySignal,
				controlSignal, createSignalFactory, promiseToSignal, manualSignal } = window.gimgen
const { pow, sqrt, random, PI } = Math
const tau = 2*PI
const sin = rTau => Math.sin(2*rTau)
const cos = rTau => Math.cos(2*rTau)
const svg = document.querySelector('svg')
const { width, height } = svg.viewBox.baseVal

const tick = timeoutSignal(1000/20)
const renderTick = timeoutSignal(1000/5)

const range = (max, min = 0) => new Array(max - min).fill(0).map((_, i) => min + i)
const rand = (max, min = 0) => random() * (max - min) + min

let id_counter = 0
const id = () => id_counter += 1

const radius = 3
const overlaps = (s1, s2) =>
    (s1.r + s2.r) >= sqrt(pow(s1.cx - s2.cx, 2) + pow(s1.cy - s2.cy, 2))
const circleShape = (id, r, [cx, cy]) => ({id, r, cx, cy })
let space = {}
let shapes = new Map()
const anyShapeOverlaps = (shape) => {
    for(let s of shapes.values())
        if(overlaps(shape, s))
            return true
    return false
}
const placeCircle = (id, remainingAttempts = 300) => {
    if(remainingAttempts <= 0)
        return null
    const location = [rand(width-radius, radius), rand(height-radius, radius)]
    const newShape = circleShape(id, radius, location)
    if(anyShapeOverlaps(newShape))
        return placeCircle(id, remainingAttempts-1)
    return newShape
}

const s = manualSignal()
const getForceAppliedSignal = () => s

const startDucky = gimgen(function * () {
  const name = `#${id()}`
  const shape = placeCircle(name)
  if(!shape)
    return console.error(`could not place circle ${id}`)
  shapes.set(name, shape)
	let direction = tau*random()
	let speed = 3 * random()
	const forceApplied = getForceAppliedSignal(name)

  while(true) {
    switch(yield anySignal(tick, forceApplied)) {
			case tick:
				shape.cx += speed*cos(direction)
				shape.cy += speed*sin(direction)
			  break;
			case forceApplied:
				break;
		}
	}
})

range(50).forEach(() => startDucky())

runGimgen(function * calcForceTransfer() {
})

runGimgen(function * renderLoop(){
  const { h, diff, patch, create } = window.virtualDom
  const renderActors = function * (shapes) {
    for(let {cx, cy, r} of shapes) {
			if(cx+r < 0 || cx-r>width || cy+r<0 || cy-r>height)
				continue
      yield h('circle', {attributes: {cx, cy, r, fill: '#AA3333'}, namespace: "http://www.w3.org/2000/svg"})
		}
  }

  const render = ({ shapes }) =>
    h('g', { namespace: "http://www.w3.org/2000/svg" }, [
        ...renderActors(shapes.values())
    ])

  let state = { shapes }
  let tree = render(state)
  const rootNode = create(tree)
  svg.appendChild(rootNode)
  while(true) {
    yield renderTick
    const newTree = render(state)
    patch(rootNode, diff(tree, newTree))
    tree = newTree
  }
})
</script>
