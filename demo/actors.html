<section>
    <p>
        Actors, Baby!
    </p>
    <figure>
        <span class="score">0</span>
        <figcaption>Max Captured</figcaption>
    </figure>
</section>
<style>
 body {
     padding: 0;
     margin: 0;
     min-height: 100vh;
     display: flex;
     flex-direction: column;
 }
 svg {
     flex: 1;
     background-color: #AABBCC;
     border: 2px solid black;
     height: 100%;
     align-self: center;
     margin-bottom: 2em;
  }
 section {
     font-size: 1.3em;
     padding: 1em;
     display: flex;
 }
 p {
     flex: 1;
 }
 figure {
     display: flex;
     flex-direction: column;
 }
</style>
<svg viewBox="0 0 100 100" preserveAspectRatio="none">
</svg>

<script src="https://rawgit.com/Matt-Esch/virtual-dom/master/dist/virtual-dom.js"></script>
<script src="../dist/gimgen.js"></script>
<script>
const { gimgen, runGimgen, timeoutSignal, domEventToSignal, anySignal, firstResolvedPromise,
				controlSignal, createSignalFactory, promiseToSignal, manualSignal } = window.gimgen
const { pow, sqrt, random, PI } = Math
const tau = 2*PI
const sin = rTau => Math.sin(2*rTau)
const cos = rTau => Math.cos(2*rTau)
const svg = document.querySelector('svg')
const { width, height } = svg.viewBox.baseVal

const tick = timeoutSignal(1000/20)
const renderTick = timeoutSignal(1000/5)

const range = (max, min = 0) => new Array(max - min).fill(0).map((_, i) => min + i)
const rand = (max, min = 0) => random() * (max - min) + min


const wrappedAnySignal = createSignalFactory('wrappedAnySignal', (_, ...signals) => {
  const signalPromise = signals.map(signal => ({signal, promise: signal.createPromise()}) )
  return firstResolvedPromise(signalPromise.map(x => x.promise))
    .then(({promise:resolvedPromise, result}) => {
			const signal = signalPromise.filter(x => x.promise === resolvedPromise)[0].signal
			return {signal, result}
		})
})

let id_counter = 0
const id = () => id_counter += 1

const radius = 3
const overlaps = (s1, s2) =>
    (s1.r + s2.r) >= sqrt(pow(s1.cx - s2.cx, 2) + pow(s1.cy - s2.cy, 2))
const circleShape = (id, r, [cx, cy]) => ({id, r, cx, cy })
let space = {}
let shapes = new Map()
const anyShapeOverlaps = (shape) => {
    for(let s of shapes.values())
        if(overlaps(shape, s))
            return true
    return false
}
const placeCircle = (id, remainingAttempts = 300) => {
    if(remainingAttempts <= 0)
        return null
    const location = [rand(width-radius, radius), rand(height-radius, radius)]
    const newShape = circleShape(id, radius, location)
    if(anyShapeOverlaps(newShape))
        return placeCircle(id, remainingAttempts-1)
    return newShape
}

const forceAppliedSignals = new Map()

const startDucky = gimgen(function * () {
  const name = `#${id()}`
  const s = placeCircle(name)
  if(!s)
    return console.error(`could not place circle ${id}`)
	s.dx = 3 * random()
	s.dy = 3 * random()
	s.forceAppliedSignal = manualSignal()
  shapes.set(name, s)

  while(true) {
		const {signal, result} = yield anySignal(tick, s.forceAppliedSignal)
    switch(signal) {
			case tick:
				s.cx += s.dx
				s.cy += s.dy
			  break;
			case s.forceAppliedSignal:
			  s.dx = result.dx
				s.dy = result.dy
				break;
		}
	}
})

range(50).forEach(startDucky)


runGimgen(function * calcForceTransfer() {
	while(true) {
		yield tick
		for(let {cy,cx,r,dx,dy, forceAppliedSignal, id} of shapes.values()) {
			if( (cy - r <= 0) || (cy + r >= height) )
				forceAppliedSignal.trigger({ dx, dy: -1*dy, })
			if( (cx - r <= 0) || (cx + r >= width) )
				forceAppliedSignal.trigger({ dx: -1*dx, dy, })

		}
	}
})

runGimgen(function * renderLoop(){
  const { h, diff, patch, create } = window.virtualDom
  const renderActors = function * (shapes) {
    for(let {cx, cy, r} of shapes) {
			if(cx+r < 0 || cx-r>width || cy+r<0 || cy-r>height)
				continue
      yield h('circle', {attributes: {cx, cy, r, fill: '#AA3333'}, namespace: "http://www.w3.org/2000/svg"})
		}
  }

  const render = ({ shapes }) =>
    h('g', { namespace: "http://www.w3.org/2000/svg" }, [
        ...renderActors(shapes.values())
    ])

  let state = { shapes }
  let tree = render(state)
  const rootNode = create(tree)
  svg.appendChild(rootNode)
  while(true) {
    yield renderTick
    const newTree = render(state)
    patch(rootNode, diff(tree, newTree))
    tree = newTree
  }
})
</script>
