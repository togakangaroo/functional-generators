<section>
    <p>
        Actors, Baby!
    </p>
    <figure>
        <span class="score">0</span>
        <figcaption>Max Captured</figcaption>
    </figure>
</section>
<style>
 body {
     padding: 0;
     margin: 0;
     min-height: 100vh;
     display: flex;
     flex-direction: column;
 }
 svg {
     flex: 1;
     background-color: #AABBCC;
     border: 2px solid black;
     height: 100%;
     align-self: center;
     margin-bottom: 2em;
  }
 section {
     font-size: 1.3em;
     padding: 1em;
     display: flex;
 }
 p {
     flex: 1;
 }
 figure {
     display: flex;
     flex-direction: column;
 }
</style>
<svg viewBox="0 0 100 100" preserveAspectRatio="none">
</svg>

<script src="https://rawgit.com/Matt-Esch/virtual-dom/master/dist/virtual-dom.js"></script>
<script src="../dist/gimgen.js"></script>
<script>
const { gimgen, runGimgen, timeoutSignal, domEventToSignal, anySignal, firstResolvedPromise,
				controlSignal, createSignalFactory, promiseToSignal, manualSignal } = window.gimgen
const { pow, sqrt, random, PI } = Math
const svg = document.querySelector('svg')
const { width, height } = svg.viewBox.baseVal

const tick = timeoutSignal(1000/60)
const renderTick = timeoutSignal(1000/30)

const range = (max, min = 0) => new Array(max - min).fill(0).map((_, i) => min + i)
const rand = (max, min = 0) => random() * (max - min) + min


const wrappedAnySignal = createSignalFactory('wrappedAnySignal', (_, ...signals) => {
  const signalPromise = signals.map(signal => ({signal, promise: signal.createPromise()}) )
  return firstResolvedPromise(signalPromise.map(x => x.promise))
    .then(({promise:resolvedPromise, result}) => {
			const signal = signalPromise.filter(x => x.promise === resolvedPromise)[0].signal
			return {signal, result}
		})
})

let id_counter = 0
const id = () => id_counter += 1

const radius = 3
const overlaps = (s1, s2) =>
    (s1.r + s2.r) >= sqrt(pow(s1.cx - s2.cx, 2) + pow(s1.cy - s2.cy, 2))
const circleShape = (id, r, [cx, cy]) => ({id, r, cx, cy })
let space = {}
let shapes = new Map()
const anyShapeOverlaps = (shape) => {
    for(let s of shapes.values())
        if(overlaps(shape, s))
            return true
    return false
}
const placeCircle = (id, remainingAttempts = 300) => {
    if(remainingAttempts <= 0)
        return null
    const location = [rand(width-radius, radius), rand(height-radius, radius)]
    const newShape = circleShape(id, radius, location)
    if(anyShapeOverlaps(newShape))
        return placeCircle(id, remainingAttempts-1)
    return newShape
}

const startDucky = gimgen(function * () {
  const name = `#${id()}`
  const s = placeCircle(name)
  if(!s)
    return console.error(`could not place circle ${id}`)
	let dx = rand(1, -1)
	let dy = rand(1, -1)
	s.forceAppliedSignal = manualSignal()
  shapes.set(name, s)

  while(true) {
		yield tick
		if( (s.cy - s.r <= 0) || (s.cy + s.r >= height) )
				dy *= -1
		if( (s.cx - s.r <= 0) || (s.cx + s.r >= width) )
				dx *= -1

		yield tick
		s.cx += dx
		s.cy += dy

	}
})

range(50).forEach(startDucky)

runGimgen(function * renderLoop(){
  const { h, diff, patch, create } = window.virtualDom
  const renderActors = function * (shapes) {
    for(let {cx, cy, r} of shapes) {
			if(cx+r < 0 || cx-r>width || cy+r<0 || cy-r>height)
				continue
      yield h('circle', {attributes: {cx, cy, r, fill: '#AA3333', stroke: '#000000', 'stroke-width': 0.2 }, namespace: "http://www.w3.org/2000/svg"})
		}
  }

  const render = ({ shapes }) =>
    h('g', { namespace: "http://www.w3.org/2000/svg" }, [
        ...renderActors(shapes.values())
    ])

  let state = { shapes }
  let tree = render(state)
  const rootNode = create(tree)
  svg.appendChild(rootNode)
  while(true) {
    yield renderTick
    const newTree = render(state)
    patch(rootNode, diff(tree, newTree))
    tree = newTree
  }
})
</script>
